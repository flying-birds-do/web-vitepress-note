# 5.4 无副作用函数

## 5.4.1 无副作用函数的定义

无副作用函数不是什么新的概念，在《领域驱动设计 软件核心复杂性应对之道》、《实现领域驱动设计》、《重构 改善既有代码的设计》等许多书中均有提及。

函数的副作用指的是函数除了其声明的作用之外，还在函数体内部做了一些暗箱操作，主要是对外进行写操作，例如修改某些全局配置项、修改某些状态值。

这种未声明的副作用很容易导致线上系统出现无法预知的异常，引发线上事故。一般来说，某个特定的调用方、在某个特定的调用时机，调用这种有未声明副作用的函数，是可以得到正确的结果的，然而一旦其他调用方在不了解函数内部实现的情况下调用了这类函数，或者在错误的时机进行了调用，就很有可能导致错误的结果。

函数产生副作用的问题，在查询和命令不分离方法中也很常见：一个方法本应该是执行命令（Command），引起领域对象状态改变的，但是却返回了查询结果；一个方法本应该是查询(Query)，不应引起领域对象状态改变的，却在内部对外实施写操作，改变了领域对象的状态。因此，查询和命令要分开：要么实现为查询，纯粹返回查询结果；要么实现为命令，纯粹进行状态变更，不返回查询结果。

无副作用函数，也就是除了函数声明的作用外，不会引起其他隐藏变化的函数，执行某个函数（即方法）时，不会修改入参、不会修改外部的状态。无副作用函数之所以在领域驱动设计中再次被提及，主要是无副作用函数的特性与值对象非常贴合，无副作用函数搭配值对象使用，能使值对象如虎添翼。

函数产生副作用的问题，举个例子：

```java
public ArticleEntity findById(String articleId){
    //根据id加载某个实体
    ArticleEntity entity=repository.load(articleId);
    //生成一个缓存key，用于统计某个实体被访问的次数
    String key="article:pv:"+articleId;
    //缓存中访问次数加1
    cache.incr(key,1);
    return entity;
}
```

以上这段代码的主要逻辑是：在CMS应用中，读者阅读某个文章时需要加载文章详情，因此提供findById方法，根据articleIdI加载文章实体，然而方法将entity返回之前，还操作缓存给这个文章的访问次数加1。这个方法理应只进行查询返回文章实体，但却在执行过程中修改文章的访问次数，因此这个方法是有副作用的。

函数的副作用很容易导致很难排查的错误。以上面的代码为例，可能一开始的时候是正常运行的，在别的地方读取这个访问次数的缓存时，也能返回正确的访问次数。随着需求的迭代，某天有个定时任务不断地根据articleIdi调用findById方法查询实体，就会突然出现访问次数离奇增加的问题。

> 实际项目中的统计某个页面的访问次数一般通过埋点和大数据实时处理，此处只是用来给展示函数的副作用，非生产环境实现方案。

另外，方法缓存自己的查询结果是无副作用的，例如：

```java
public ArticleEntity findById2(String articleId){

    String key="article:"+articleId;
    ArticleEntity entity=cache.get(key);
    if(entity!=null){
				return entity;
    }
    entity=repository.load(articleId);
    cache.set(key,entity);
    return entity;
}
```

findById2这个方法通过articleId查询文章，查询时先尝试通过缓存获取，如果能获取到，直接返回从缓存中取出来的文章；如果获取不到则通过repository的load方法加载，并将其缓存。虽然在这个方法中也操作了缓存，但是并没有对外造成影响，所以findById2也是无副作用的。

## 5.4.2 无副作用函数的实现方法

无副作用函数有两种实现方式：纯函数，以及不修改外部数据的非纯函数。

* 纯函数

纯函数是指，用于计算的所有输入均来自方法的入参，函数计算时不依赖非入参的数据，函数执行的结果只通过返回值传递到外部，不会修改入参的函数。

举个例子：

```java
//这是一个纯函数，函数不依赖非入参的外部数据，执行的结果通过返回值传递到外部
public int sum(int x,int y){
    return x+y;
}
```

* 非纯函数

非纯函数在执行的过程中依赖了外部的数据，如果希望非纯函数成为无副作用函数，那么非纯函数不应该修改外部的值。

```java
public class CustomInt{

    private int a;

    public CustomInt(int a){
        this.a=a;
    }

    //这个方法依赖了属性a，但是并没有修改a的值
    public int plus(int x){
        return a+x;
    }
}
```

以上这个plus方法在计算时不仅依赖入参x，还需要依赖CustomInt的属性a，因此plus方法是非纯函数。

虽然plus方法依赖了CustomInt的属性a，但是plus方法并没有修改a的值，因此plus方法也是无副作用的。
